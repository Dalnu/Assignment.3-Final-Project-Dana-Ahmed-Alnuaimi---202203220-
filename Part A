# 1. If you need to find a post by its unique datetime value, what data structure would you use? Implement your solution.
class HashTable:
    def __init__(self):
        self.size = 1000  # Adjust the size based on the expected number of posts
        self.table = [None] * self.size

    def _hash(self, key):
        return hash(key) % self.size

    def insert(self, key, value):
        index = self._hash(key)
        if self.table[index] is None:
            self.table[index] = [(key, value)]
        else:
            for i, (existing_key, _) in enumerate(self.table[index]):
                if existing_key == key:
                    self.table[index][i] = (key, value)
                    break
            else:
                self.table[index].append((key, value))

    def get(self, key):
        index = self._hash(key)
        if self.table[index] is None:
            return None
        for existing_key, value in self.table[index]:
            if existing_key == key:
                return value
        return None

# Test cases for finding a post by unique datetime value using Hash Table
hash_table = HashTable()

# Inserting posts with unique datetime values
hash_table.insert("2024-04-22 10:00:00", "Post 1")
hash_table.insert("2024-04-22 12:30:00", "Post 2")
hash_table.insert("2024-04-22 15:45:00", "Post 3")

# Retrieving posts by their datetime values
print(hash_table.get("2024-04-22 10:00:00"))  # Output: Post 1
print(hash_table.get("2024-04-22 12:30:00"))  # Output: Post 2
print(hash_table.get("2024-04-22 15:45:00"))  # Output: Post 3


# __________________________________________________________________________________________________________________________________________________________________________________________________

# 2. If you need to find posts in a specific time range (e.g., start datetime, end datetime), what data structure would you use? Why? Implement your solution.
class TreeNode:
    def __init__(self, datetime, post):
        self.datetime = datetime
        self.post = post
        self.left = None
        self.right = None

class BST:
    def __init__(self):
        self.root = None

    def insert(self, datetime, post):
        if not self.root:
            self.root = TreeNode(datetime, post)
        else:
            self._insert_recursive(self.root, datetime, post)

    def _insert_recursive(self, node, datetime, post):
        if datetime < node.datetime:
            if node.left:
                self._insert_recursive(node.left, datetime, post)
            else:
                node.left = TreeNode(datetime, post)
        else:
            if node.right:
                self._insert_recursive(node.right, datetime, post)
            else:
                node.right = TreeNode(datetime, post)

    def find_posts_in_range(self, start_datetime, end_datetime):
        result = []
        if self.root:
            self._find_posts_in_range_recursive(self.root, start_datetime, end_datetime, result)
        return result

    def _find_posts_in_range_recursive(self, node, start_datetime, end_datetime, result):
        if not node:
            return
        if start_datetime <= node.datetime <= end_datetime:
            result.append(node.post)
        if start_datetime < node.datetime:
            self._find_posts_in_range_recursive(node.left, start_datetime, end_datetime, result)
        if end_datetime > node.datetime:
            self._find_posts_in_range_recursive(node.right, start_datetime, end_datetime, result)

# Test cases for finding posts in a specific time range using Binary Search Tree
bst = BST()

# Inserting posts with datetime values
bst.insert("2024-04-22 10:00:00", "Post 1")
bst.insert("2024-04-22 12:30:00", "Post 2")
bst.insert("2024-04-22 15:45:00", "Post 3")

# Finding posts within a time range
print(bst.find_posts_in_range("2024-04-22 11:00:00", "2024-04-22 14:00:00"))  # Output: ['Post 2']



# __________________________________________________________________________________________________________________________________________________________________________________________________

# 3. Imagine that we want to prioritize the social media posts by the number of views, and we want to be able to retrieve the post with the most views. What data structure would you use? Why? Implement your solution.
import heapq

class PostManager:
    def __init__(self):
        self.posts = []

    def add_post_with_views(self, post, views):
        heapq.heappush(self.posts, (-views, post))

    def get_most_viewed_post(self):
        most_viewed_post = self.posts[0][1] if self.posts else None
        if most_viewed_post:
            return most_viewed_post
        else:
            return "No posts available."

# Test cases for prioritizing posts by number of views using Max Heap
post_manager = PostManager()

# Adding posts with views
post_manager.add_post_with_views("Post 1", 10)
post_manager.add_post_with_views("Post 2", 20)
post_manager.add_post_with_views("Post 3", 15)

# Retrieving the most viewed post
print(post_manager.get_most_viewed_post())  # Output: Post 2
