# 1. If you need to find a post by its unique datetime value, what data structure would you use? Implement your solution.
class HashTable:
    def __init__(self):
        self.size = 1000  # Adjust the size based on the expected number of posts
        self.table = [None] * self.size

    def _hash(self, key):
        return hash(key) % self.size

    def insert(self, key, value):
        index = self._hash(key)
        if self.table[index] is None:
            self.table[index] = [(key, value)]
        else:
            for i, (existing_key, _) in enumerate(self.table[index]):
                if existing_key == key:
                    self.table[index][i] = (key, value)
                    break
            else:
                self.table[index].append((key, value))

    def get(self, key):
        index = self._hash(key)
        if self.table[index] is None:
            return None
        for existing_key, value in self.table[index]:
            if existing_key == key:
                return value
        return None



# Test cases for finding a post by unique datetime value using Hash Table
# Test Case 1: Insert and Retrieve
hash_table = HashTable()
date = "2024-04-21"
time = "12:00:00"
post = "Sample post content"
datetime = date + " " + time
hash_table.insert(datetime, post)
retrieved_post = hash_table.get(datetime)
assert retrieved_post == post, "Test case 1 failed: Retrieved post does not match inserted post."

# Test Case 2: Collision Handling
hash_table = HashTable()
date = "2024-04-21"
time = "12:00:00"
post1 = "First post"
post2 = "Second post"
datetime = date + " " + time
hash_table.insert(datetime, post1)
hash_table.insert(datetime, post2)
retrieved_posts = []
for key in hash_table.table:
    if key:
        for _, value in key:
            retrieved_posts.append(value)
assert post1 in retrieved_posts and post2 in retrieved_posts, "Test case 2 failed: Not all posts are retrieved."

# Test Case 3: Non-existent Datetime
hash_table = HashTable()
date = "2024-04-21"
time = "12:00:00"
non_existent_date = "2024-04-22"
non_existent_time = "12:00:00"
post = "Sample post content"
datetime = date + " " + time
hash_table.insert(datetime, post)
non_existent_datetime = non_existent_date + " " + non_existent_time
retrieved_post = hash_table.get(non_existent_datetime)
assert retrieved_post is None, "Test case 3 failed: Retrieved post exists for non-existent datetime."



# __________________________________________________________________________________________________________________________________________________________________________________________________

# 2. If you need to find posts in a specific time range (e.g., start datetime, end datetime), what data structure would you use? Why? Implement your solution.
class TreeNode:
    def __init__(self, datetime, post):
        self.datetime = datetime
        self.post = post
        self.left = None
        self.right = None

class BST:
    def __init__(self):
        self.root = None

    def insert(self, datetime, post):
        if not self.root:
            self.root = TreeNode(datetime, post)
        else:
            self._insert_recursive(self.root, datetime, post)

    def _insert_recursive(self, node, datetime, post):
        if datetime < node.datetime:
            if node.left:
                self._insert_recursive(node.left, datetime, post)
            else:
                node.left = TreeNode(datetime, post)
        else:
            if node.right:
                self._insert_recursive(node.right, datetime, post)
            else:
                node.right = TreeNode(datetime, post)

    def find_posts_in_range(self, start_datetime, end_datetime):
        result = []
        if self.root:
            self._find_posts_in_range_recursive(self.root, start_datetime, end_datetime, result)
        return result

    def _find_posts_in_range_recursive(self, node, start_datetime, end_datetime, result):
        if not node:
            return
        if start_datetime <= node.datetime <= end_datetime:
            result.append(node.post)
        if start_datetime < node.datetime:
            self._find_posts_in_range_recursive(node.left, start_datetime, end_datetime, result)
        if end_datetime > node.datetime:
            self._find_posts_in_range_recursive(node.right, start_datetime, end_datetime, result)



# Test cases for finding posts in a specific time range using Binary Search Tree
# Test Case 1: Insert and Retrieve in Range
bst = BST()
# Assuming that the posts are inserted with datetime values spanning a range from "2024-04-01" to "2024-04-30"
# Define a time range from "2024-04-10 00:00:00" to "2024-04-20 23:59:59"
start_date = "2024-04-10"
end_date = "2024-04-20"
start_time = "00:00:00"
end_time = "23:59:59"
start_datetime = start_date + " " + start_time
end_datetime = end_date + " " + end_time
posts_in_range = bst.find_posts_in_range(start_datetime, end_datetime)
assert len(posts_in_range) > 0, "Test case 1 failed: No posts retrieved within the specified time range."

# Test Case 2: No Posts in Range
# Assumeing that the posts are inserted with datetime values outside the defined time range
# A time range from "2024-04-25 00:00:00" to "2024-04-30 23:59:59"
start_date = "2024-04-25"
end_date = "2024-04-30"
start_time = "00:00:00"
end_time = "23:59:59"
start_datetime = start_date + " " + start_time
end_datetime = end_date + " " + end_time
posts_in_range = bst.find_posts_in_range(start_datetime, end_datetime)
assert len(posts_in_range) == 0, "Test case 2 failed: Posts retrieved within the specified time range."

# Test Case 3: Partially Overlapping Range
# Assuming that the posts are inserted with datetime values partially overlapping with the defined time range
# Define a time range from "2024-04-15 12:00:00" to "2024-04-25 12:00:00"
start_date = "2024-04-15"
end_date = "2024-04-25"
start_time = "12:00:00"
end_time = "12:00:00"
start_datetime = start_date + " " + start_time
end_datetime = end_date + " " + end_time
posts_in_range = bst.find_posts_in_range(start_datetime, end_datetime)
assert len(posts_in_range) > 0, "Test case 3 failed: No posts retrieved within the overlapping time range."





# __________________________________________________________________________________________________________________________________________________________________________________________________

# 3. Imagine that we want to prioritize the social media posts by the number of views, and we want to be able to retrieve the post with the most views. What data structure would you use? Why? Implement your solution.
import heapq

class PostManager:
    def __init__(self):
        self.posts = []

    def add_post_with_views(self, post, views):
        heapq.heappush(self.posts, (-views, post))

    def get_most_viewed_post(self):
        most_viewed_post = self.posts[0][1] if self.posts else None
        if most_viewed_post:
            return most_viewed_post
        else:
            return "No posts available."

# Test cases for prioritizing posts by number of views using Max Heap
post_manager = PostManager()

# Adding posts with views
post_manager.add_post_with_views("Post 1", 123456789)
post_manager.add_post_with_views("Post 2", 1234567)
post_manager.add_post_with_views("Post 3", 1234567890)

# Retrieving the most viewed post
print(post_manager.get_most_viewed_post())  # Output: Post 2



# Test Case 1: Insert and Retrieve Most Viewed Post
post_manager = PostManager()
post_manager.add_post_with_views("Post 1", 234567890)
post_manager.add_post_with_views("Post 2", 3456789)
post_manager.add_post_with_views("Post 3", 23456)
most_viewed_post = post_manager.get_most_viewed_post()
assert most_viewed_post == "Post 1", "Test case 1 failed: Incorrect most viewed post retrieved."

# Test Case 2: Retrieve Top N Most Viewed Posts
top_n_posts = post_manager.get_most_viewed_posts(2)
assert top_n_posts == ["Post 1", "Post 3"], "Test case 2 failed: Incorrect top N most viewed posts retrieved."

# Test Case 3: No Posts Available
empty_post_manager = PostManager()
most_viewed_post = empty_post_manager.get_most_viewed_post()
assert most_viewed_post == "No posts available.", "Test case 3 failed: Incorrect message for no posts available."
