# 1. If you need to find a post by its unique datetime value, what data structure would you use? Implement your solution.
class HashTable:
    def __init__(self):
        self.size = 1000  # Adjust the size based on the expected number of posts
        self.table = [None] * self.size

    def _hash(self, key):
        return hash(key) % self.size

    def insert(self, key, value):
        index = self._hash(key)
        if self.table[index] is None:
            self.table[index] = [(key, value)]
        else:
            for i, (existing_key, _) in enumerate(self.table[index]):
                if existing_key == key:
                    self.table[index][i] = (key, value)
                    break
            else:
                self.table[index].append((key, value))

    def get(self, key):
        index = self._hash(key)
        if self.table[index] is None:
            return None
        for existing_key, value in self.table[index]:
            if existing_key == key:
                return value
        return None

# Test cases for finding a post by unique datetime value using Hash Table
# Test Case 1: Insert and Retrieve
hash_table = HashTable()
date = "2024-04-21"
time = "12:00:00"
post = "Sample post content"
datetime = date + " " + time
hash_table.insert(datetime, post)
retrieved_post = hash_table.get(datetime)
assert retrieved_post == post, "Test case 1 failed: Retrieved post does not match inserted post."

# Test Case 2: Collision Handling
hash_table = HashTable()
date = "2024-04-21"
time = "12:00:00"
post1 = "First post"
post2 = "Second post"
datetime = date + " " + time
hash_table.insert(datetime, post1)
hash_table.insert(datetime, post2)
retrieved_posts = []
for key in hash_table.table:
    if key:
        for _, value in key:
            retrieved_posts.append(value)
assert post1 in retrieved_posts and post2 in retrieved_posts, "Test case 2 failed: Not all posts are retrieved."

# Test Case 3: Non-existent Datetime
hash_table = HashTable()
date = "2024-04-21"
time = "12:00:00"
non_existent_date = "2024-04-22"
non_existent_time = "12:00:00"
post = "Sample post content"
datetime = date + " " + time
hash_table.insert(datetime, post)
non_existent_datetime = non_existent_date + " " + non_existent_time
retrieved_post = hash_table.get(non_existent_datetime)
assert retrieved_post is None, "Test case 3 failed: Retrieved post exists for non-existent datetime."

# __________________________________________________________________________________________________________________________________________________________________________________________________

# 2. If you need to find posts in a specific time range (e.g., start datetime, end datetime), what data structure would you use? Why? Implement your solution.
class TreeNode:
    def __init__(self, datetime, post):
        self.datetime = datetime
        self.post = post
        self.left = None
        self.right = None

class BST:
    def __init__(self):
        self.root = None

    def insert(self, datetime, post):
        if not self.root:
            self.root = TreeNode(datetime, post)
        else:
            self._insert_recursive(self.root, datetime, post)

    def _insert_recursive(self, node, datetime, post):
        if datetime < node.datetime:
            if node.left:
                self._insert_recursive(node.left, datetime, post)
            else:
                node.left = TreeNode(datetime, post)
        else:
            if node.right:
                self._insert_recursive(node.right, datetime, post)
            else:
                node.right = TreeNode(datetime, post)

    def find_posts_in_range(self, start_datetime, end_datetime):
        result = []
        if self.root:
            self._find_posts_in_range_recursive(self.root, start_datetime, end_datetime, result)
        return result

    def _find_posts_in_range_recursive(self, node, start_datetime, end_datetime, result):
        if not node:
            return
        if start_datetime <= node.datetime <= end_datetime:
            result.append(node.post)
        if start_datetime < node.datetime:
            self._find_posts_in_range_recursive(node.left, start_datetime, end_datetime, result)
        if end_datetime > node.datetime:
            self._find_posts_in_range_recursive(node.right, start_datetime, end_datetime, result)

# Test cases for finding posts in a specific time range using Binary Search Tree
bst = BST()

# Inserting posts with datetime values
bst.insert("2024-04-22 10:00:00", "Post 1")
bst.insert("2024-04-22 12:30:00", "Post 2")
bst.insert("2024-04-22 15:45:00", "Post 3")

# Finding posts within a time range
print(bst.find_posts_in_range("2024-04-22 11:00:00", "2024-04-22 14:00:00"))  # Output: ['Post 2']



# __________________________________________________________________________________________________________________________________________________________________________________________________

# 3. Imagine that we want to prioritize the social media posts by the number of views, and we want to be able to retrieve the post with the most views. What data structure would you use? Why? Implement your solution.
import heapq

class PostManager:
    def __init__(self):
        self.posts = []

    def add_post_with_views(self, post, views):
        heapq.heappush(self.posts, (-views, post))

    def get_most_viewed_post(self):
        most_viewed_post = self.posts[0][1] if self.posts else None
        if most_viewed_post:
            return most_viewed_post
        else:
            return "No posts available."

# Test cases for prioritizing posts by number of views using Max Heap
post_manager = PostManager()

# Adding posts with views
post_manager.add_post_with_views("Post 1", 10)
post_manager.add_post_with_views("Post 2", 20)
post_manager.add_post_with_views("Post 3", 15)

# Retrieving the most viewed post
print(post_manager.get_most_viewed_post())  # Output: Post 2
